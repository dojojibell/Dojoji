{"ast":null,"code":"var _jsxFileName = \"/Users/ivopascoal/Desktop/Dojoji/src/contexts/data.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useState, useContext, useMemo, useEffect, createContext } from 'react';\nimport _flatten from 'lodash/flatten';\nimport _orderBy from 'lodash/orderBy';\nimport { useWallet } from 'contexts/wallet';\nimport { useContracts } from 'contexts/contracts';\nimport useTokenInfo from 'hooks/useTokenInfo';\nimport { toBigNumber } from 'utils/big-number';\nimport * as request from 'utils/request';\nimport { SUBGRAPHS } from 'config';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DataContext = /*#__PURE__*/createContext(null);\nexport const DataProvider = ({\n  children\n}) => {\n  _s();\n\n  var _currentIncentive$key;\n\n  const {\n    stakingRewardsContract,\n    nftManagerPositionsContract\n  } = useContracts();\n  const {\n    network,\n    address\n  } = useWallet();\n  const [positions, setPositions] = useState([]);\n  const [incentives, setIncentiveIds] = useState([]);\n  const [currentIncentiveId, setCurrentIncentiveId] = useState(null);\n  const currentIncentive = useMemo(() => {\n    var _incentives$find;\n\n    return !currentIncentiveId ? null : (_incentives$find = incentives.find(incentive => incentive.id === currentIncentiveId)) !== null && _incentives$find !== void 0 ? _incentives$find : null;\n  }, [currentIncentiveId, incentives]);\n  const {\n    decimals: currentIncentiveRewardTokenDecimals,\n    symbol: currentIncentiveRewardTokenSymbol\n  } = useTokenInfo((_currentIncentive$key = currentIncentive === null || currentIncentive === void 0 ? void 0 : currentIncentive.key.rewardToken) !== null && _currentIncentive$key !== void 0 ? _currentIncentive$key : null); // load incentives\n\n  useEffect(() => {\n    if (!network) return;\n\n    const load = async () => {\n      var _incentives$0$id, _incentives$;\n\n      const subgraph = request.subgraph(SUBGRAPHS[network]);\n      const {\n        incentives\n      } = await subgraph(`query {\n          incentives(orderBy: endTime, orderDirection: desc) {\n            id\n            rewardToken\n            pool\n            startTime\n            endTime\n            refundee\n            reward\n            ended\n          }\n        }`, {});\n      setIncentiveIds(incentives.map(({\n        id,\n        rewardToken,\n        pool,\n        startTime,\n        endTime,\n        refundee,\n        reward,\n        ended\n      }) => ({\n        id,\n        reward: toBigNumber(reward),\n        ended,\n        key: {\n          rewardToken,\n          pool,\n          startTime: Number(startTime),\n          endTime: Number(endTime),\n          refundee\n        }\n      })));\n      setCurrentIncentiveId((_incentives$0$id = (_incentives$ = incentives[0]) === null || _incentives$ === void 0 ? void 0 : _incentives$.id) !== null && _incentives$0$id !== void 0 ? _incentives$0$id : null);\n    };\n\n    load();\n  }, [network]); // load owned and transfered positions\n\n  useEffect(() => {\n    if (!(nftManagerPositionsContract && stakingRewardsContract && address && currentIncentiveId && currentIncentive)) return;\n    let isMounted = true;\n    const unsubs = [() => {\n      isMounted = false;\n    }];\n\n    const loadPositions = async owner => {\n      const noOfPositions = await nftManagerPositionsContract.balanceOf(owner);\n      const positions = await Promise.all(new Array(noOfPositions.toNumber()).fill(0).map((_, index) => loadPosition(owner, index)));\n      const ownerPositions = [];\n      positions.forEach(position => {\n        if (position) {\n          ownerPositions.push(position);\n        }\n      });\n      return ownerPositions;\n    };\n\n    const loadPosition = async (owner, index) => {\n      const tokenId = await nftManagerPositionsContract.tokenOfOwnerByIndex(owner, index);\n      const {\n        liquidity\n      } = await nftManagerPositionsContract.positions(tokenId);\n      if (liquidity.isZero()) return null;\n      const position = await stakingRewardsContract.deposits(tokenId);\n      if (owner !== address && position.owner !== address) return null;\n      let staked = false;\n      let reward = toBigNumber(0);\n\n      try {\n        const [rewardNumber] = await stakingRewardsContract.getRewardInfo(currentIncentive.key, tokenId);\n        reward = toBigNumber(rewardNumber.toString());\n        staked = true;\n      } catch {}\n\n      return {\n        tokenId: Number(tokenId.toString()),\n        owner,\n        reward,\n        staked\n      };\n    };\n\n    const load = async () => {\n      const owners = [address, stakingRewardsContract.address];\n      const positions = await Promise.all(owners.map(loadPositions));\n\n      if (isMounted) {\n        setPositions(_orderBy(_flatten(positions), 'tokenId'));\n      }\n    };\n\n    load();\n    return () => {\n      unsubs.map(u => u());\n    };\n  }, [nftManagerPositionsContract, stakingRewardsContract, address, currentIncentiveId, currentIncentive]);\n  useEffect(() => {\n    if (!(stakingRewardsContract && currentIncentiveId)) return;\n    let isMounted = true;\n    const unsubs = [() => {\n      isMounted = false;\n    }];\n\n    const updateStaked = (tokenId, incentiveId) => {\n      if (incentiveId !== currentIncentiveId) return;\n\n      if (isMounted) {\n        setPositions(positions => positions.map(position => {\n          if (position.tokenId !== Number(tokenId.toString())) return position;\n          position.staked = true;\n          return position;\n        }));\n      }\n    };\n\n    const updateUnstaked = (tokenId, incentiveId) => {\n      if (incentiveId !== currentIncentiveId) return;\n\n      if (isMounted) {\n        setPositions(positions => positions.map(position => {\n          if (position.tokenId !== Number(tokenId.toString())) return position;\n          position.staked = false;\n          return position;\n        }));\n      }\n    };\n\n    const subscribe = () => {\n      const stakedEvent = stakingRewardsContract.filters.TokenStaked();\n      const unstakedEvent = stakingRewardsContract.filters.TokenUnstaked();\n      stakingRewardsContract.on(stakedEvent, updateStaked);\n      stakingRewardsContract.on(unstakedEvent, updateUnstaked);\n      unsubs.push(() => {\n        stakingRewardsContract.off(stakedEvent, updateStaked);\n      });\n      unsubs.push(() => {\n        stakingRewardsContract.off(unstakedEvent, updateUnstaked);\n      });\n    };\n\n    subscribe();\n    return () => {\n      unsubs.map(u => u());\n    };\n  }, [stakingRewardsContract, positions, currentIncentiveId]);\n  return /*#__PURE__*/_jsxDEV(DataContext.Provider, {\n    value: {\n      positions,\n      incentives,\n      currentIncentiveId,\n      currentIncentive,\n      setCurrentIncentiveId,\n      currentIncentiveRewardTokenSymbol,\n      currentIncentiveRewardTokenDecimals\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 269,\n    columnNumber: 5\n  }, this);\n};\n\n_s(DataProvider, \"R2Nc9dsNiqGI4WfrhrHyZCINeiY=\", false, function () {\n  return [useContracts, useWallet, useTokenInfo];\n});\n\n_c = DataProvider;\nexport function useData() {\n  _s2();\n\n  const context = useContext(DataContext);\n\n  if (!context) {\n    throw new Error('Missing Data context');\n  }\n\n  const {\n    positions,\n    incentives,\n    currentIncentiveId,\n    currentIncentive,\n    setCurrentIncentiveId,\n    currentIncentiveRewardTokenSymbol,\n    currentIncentiveRewardTokenDecimals\n  } = context;\n  return {\n    positions,\n    incentives,\n    currentIncentiveId,\n    currentIncentive,\n    setCurrentIncentiveId,\n    currentIncentiveRewardTokenSymbol,\n    currentIncentiveRewardTokenDecimals\n  };\n}\n\n_s2(useData, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nvar _c;\n\n$RefreshReg$(_c, \"DataProvider\");","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/Dojoji/src/contexts/data.tsx"],"names":["useState","useContext","useMemo","useEffect","createContext","_flatten","_orderBy","useWallet","useContracts","useTokenInfo","toBigNumber","request","SUBGRAPHS","DataContext","DataProvider","children","stakingRewardsContract","nftManagerPositionsContract","network","address","positions","setPositions","incentives","setIncentiveIds","currentIncentiveId","setCurrentIncentiveId","currentIncentive","find","incentive","id","decimals","currentIncentiveRewardTokenDecimals","symbol","currentIncentiveRewardTokenSymbol","key","rewardToken","load","subgraph","map","pool","startTime","endTime","refundee","reward","ended","Number","isMounted","unsubs","loadPositions","owner","noOfPositions","balanceOf","Promise","all","Array","toNumber","fill","_","index","loadPosition","ownerPositions","forEach","position","push","tokenId","tokenOfOwnerByIndex","liquidity","isZero","deposits","staked","rewardNumber","getRewardInfo","toString","owners","u","updateStaked","incentiveId","updateUnstaked","subscribe","stakedEvent","filters","TokenStaked","unstakedEvent","TokenUnstaked","on","off","useData","context","Error"],"mappings":"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","sourcesContent":["import {\n  FC,\n  useState,\n  useContext,\n  useMemo,\n  useEffect,\n  createContext,\n  ReactNode,\n} from 'react';\nimport _flatten from 'lodash/flatten';\nimport _orderBy from 'lodash/orderBy';\n\nimport { useWallet } from 'contexts/wallet';\nimport { useContracts } from 'contexts/contracts';\nimport useTokenInfo from 'hooks/useTokenInfo';\nimport { Incentive, LiquidityPosition } from 'utils/types';\nimport { toBigNumber } from 'utils/big-number';\nimport * as request from 'utils/request';\nimport { SUBGRAPHS } from 'config';\n\nconst DataContext = createContext<{\n  positions: LiquidityPosition[];\n  incentives: Incentive[];\n  currentIncentiveId: string | null;\n  currentIncentive: Incentive | null;\n  setCurrentIncentiveId: (id: string) => void;\n  currentIncentiveRewardTokenSymbol: string | null;\n  currentIncentiveRewardTokenDecimals: number | null;\n} | null>(null);\n\nexport const DataProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const {\n    stakingRewardsContract,\n    nftManagerPositionsContract,\n  } = useContracts();\n  const { network, address } = useWallet();\n  const [positions, setPositions] = useState<LiquidityPosition[]>([]);\n  const [incentives, setIncentiveIds] = useState<Incentive[]>([]);\n  const [currentIncentiveId, setCurrentIncentiveId] = useState<string | null>(\n    null\n  );\n\n  const currentIncentive = useMemo(\n    () =>\n      !currentIncentiveId\n        ? null\n        : incentives.find((incentive) => incentive.id === currentIncentiveId) ??\n          null,\n    [currentIncentiveId, incentives]\n  );\n\n  const {\n    decimals: currentIncentiveRewardTokenDecimals,\n    symbol: currentIncentiveRewardTokenSymbol,\n  } = useTokenInfo(currentIncentive?.key.rewardToken ?? null);\n\n  // load incentives\n  useEffect(() => {\n    if (!network) return;\n\n    const load = async () => {\n      const subgraph = request.subgraph(SUBGRAPHS[network])!;\n      const { incentives } = await subgraph(\n        `query {\n          incentives(orderBy: endTime, orderDirection: desc) {\n            id\n            rewardToken\n            pool\n            startTime\n            endTime\n            refundee\n            reward\n            ended\n          }\n        }`,\n        {}\n      );\n      setIncentiveIds(\n        incentives.map(\n          ({\n            id,\n            rewardToken,\n            pool,\n            startTime,\n            endTime,\n            refundee,\n            reward,\n            ended,\n          }: {\n            id: string;\n            rewardToken: string;\n            pool: string;\n            startTime: number;\n            endTime: number;\n            refundee: string;\n            reward: number;\n            ended: boolean;\n          }) =>\n            ({\n              id,\n              reward: toBigNumber(reward),\n              ended,\n              key: {\n                rewardToken,\n                pool,\n                startTime: Number(startTime),\n                endTime: Number(endTime),\n                refundee,\n              },\n            } as Incentive)\n        )\n      );\n      setCurrentIncentiveId(incentives[0]?.id ?? null);\n    };\n\n    load();\n  }, [network]);\n\n  // load owned and transfered positions\n  useEffect(() => {\n    if (\n      !(\n        nftManagerPositionsContract &&\n        stakingRewardsContract &&\n        address &&\n        currentIncentiveId &&\n        currentIncentive\n      )\n    )\n      return;\n\n    let isMounted = true;\n    const unsubs = [\n      () => {\n        isMounted = false;\n      },\n    ];\n\n    const loadPositions = async (owner: string) => {\n      const noOfPositions = await nftManagerPositionsContract.balanceOf(owner);\n      const positions = await Promise.all(\n        new Array(noOfPositions.toNumber())\n          .fill(0)\n          .map((_, index) => loadPosition(owner, index))\n      );\n      const ownerPositions: LiquidityPosition[] = [];\n      positions.forEach((position) => {\n        if (position) {\n          ownerPositions.push(position);\n        }\n      });\n      return ownerPositions;\n    };\n\n    const loadPosition = async (\n      owner: string,\n      index: number\n    ): Promise<LiquidityPosition | null> => {\n      const tokenId = await nftManagerPositionsContract.tokenOfOwnerByIndex(\n        owner,\n        index\n      );\n      const { liquidity } = await nftManagerPositionsContract.positions(\n        tokenId\n      );\n      if (liquidity.isZero()) return null;\n      const position = await stakingRewardsContract.deposits(tokenId);\n      if (owner !== address && position.owner !== address) return null;\n      let staked = false;\n      let reward = toBigNumber(0);\n      try {\n        const [rewardNumber] = await stakingRewardsContract.getRewardInfo(\n          currentIncentive.key,\n          tokenId\n        );\n        reward = toBigNumber(rewardNumber.toString());\n        staked = true;\n      } catch {}\n      return {\n        tokenId: Number(tokenId.toString()),\n        owner,\n        reward,\n        staked,\n      };\n    };\n\n    const load = async () => {\n      const owners: string[] = [address, stakingRewardsContract.address];\n      const positions = await Promise.all(owners.map(loadPositions));\n      if (isMounted) {\n        setPositions(_orderBy(_flatten(positions), 'tokenId'));\n      }\n    };\n\n    load();\n\n    return () => {\n      unsubs.map((u) => u());\n    };\n  }, [\n    nftManagerPositionsContract,\n    stakingRewardsContract,\n    address,\n    currentIncentiveId,\n    currentIncentive,\n  ]);\n\n  useEffect(() => {\n    if (!(stakingRewardsContract && currentIncentiveId)) return;\n\n    let isMounted = true;\n    const unsubs = [\n      () => {\n        isMounted = false;\n      },\n    ];\n\n    const updateStaked = (tokenId: number, incentiveId: string) => {\n      if (incentiveId !== currentIncentiveId) return;\n      if (isMounted) {\n        setPositions((positions) =>\n          positions.map((position) => {\n            if (position.tokenId !== Number(tokenId.toString()))\n              return position;\n            position.staked = true;\n            return position;\n          })\n        );\n      }\n    };\n\n    const updateUnstaked = (tokenId: number, incentiveId: string) => {\n      if (incentiveId !== currentIncentiveId) return;\n      if (isMounted) {\n        setPositions((positions) =>\n          positions.map((position) => {\n            if (position.tokenId !== Number(tokenId.toString()))\n              return position;\n            position.staked = false;\n            return position;\n          })\n        );\n      }\n    };\n\n    const subscribe = () => {\n      const stakedEvent = stakingRewardsContract.filters.TokenStaked();\n      const unstakedEvent = stakingRewardsContract.filters.TokenUnstaked();\n\n      stakingRewardsContract.on(stakedEvent, updateStaked);\n      stakingRewardsContract.on(unstakedEvent, updateUnstaked);\n\n      unsubs.push(() => {\n        stakingRewardsContract.off(stakedEvent, updateStaked);\n      });\n      unsubs.push(() => {\n        stakingRewardsContract.off(unstakedEvent, updateUnstaked);\n      });\n    };\n\n    subscribe();\n\n    return () => {\n      unsubs.map((u) => u());\n    };\n  }, [stakingRewardsContract, positions, currentIncentiveId]);\n\n  return (\n    <DataContext.Provider\n      value={{\n        positions,\n        incentives,\n        currentIncentiveId,\n        currentIncentive,\n        setCurrentIncentiveId,\n        currentIncentiveRewardTokenSymbol,\n        currentIncentiveRewardTokenDecimals,\n      }}\n    >\n      {children}\n    </DataContext.Provider>\n  );\n};\n\nexport function useData() {\n  const context = useContext(DataContext);\n  if (!context) {\n    throw new Error('Missing Data context');\n  }\n  const {\n    positions,\n    incentives,\n    currentIncentiveId,\n    currentIncentive,\n    setCurrentIncentiveId,\n    currentIncentiveRewardTokenSymbol,\n    currentIncentiveRewardTokenDecimals,\n  } = context;\n\n  return {\n    positions,\n    incentives,\n    currentIncentiveId,\n    currentIncentive,\n    setCurrentIncentiveId,\n    currentIncentiveRewardTokenSymbol,\n    currentIncentiveRewardTokenDecimals,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}